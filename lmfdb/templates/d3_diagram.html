{% extends 'homepage.html' %}
{% block content %}

<!-- TODO: replace this with a diagram-specific search form -->
{% include 'refine_search_form.html' %}

<!-- Load d3.js -->
<script src="https://d3js.org/d3.v4.js"></script>
<script src="https://d3js.org/d3-scale-chromatic.v1.js"> </script>

<!-- Container for diagram and controls -->
<div id="diagram-container" style="position: relative;" >

<!-- Create a div where the graph will take place -->
<div id="my_dataviz"></div>

  <!-- Control panel -->
  <div style="margin-top: 20px; margin-left: 60px; padding: 15px; border: 1px solid #ccc; border-radius: 5px; display: inline-block;">
    <div style="margin-bottom: 15px;">
      <label for="pointRadius">Point Radius: <span id="radiusValue">1.5</span></label>
      <input type="range" id="pointRadius" min="0.5" max="10" value="1.5" step="0.2" style="width: 200px; margin-left: 10px; vertical-align: middle;">
    </div>
    <div style="display: grid; grid-template-columns: auto auto auto; gap: 10px 20px; margin-bottom: 15px; align-items: start;">
      <div>
        <label for="xMax">xMax:</label>
        <input type="number" id="xMax" value="" step="any" style="width: 80px; margin-left: 10px;">
      </div>
      <div>
        <label for="yMax">yMax:</label>
        <input type="number" id="yMax" value="" step="any" style="width: 80px; margin-left: 10px;">
      </div>
      <div style="grid-row: span 2;">
        <label for="colorScheme" style="display: block; margin-bottom: 5px;">Color Scheme:</label>
        <select id="colorScheme" style="width: 150px;">
          <option value="viridis">Viridis</option>
          <option value="plasma">Plasma</option>
          <option value="inferno">Inferno</option>
          <option value="cubehelix">Cubehelix</option>
          <option value="warm">Warm</option>
        </select>
        <div id="colorPreview" style="margin-top: 8px; height: 20px; border: 1px solid #ccc; border-radius: 3px;"></div>
        <div id="binaryLabels" style="margin-top: 5px; font-size: 11px; color: #666; display: none;">
          <span style="float: left;">0</span>
          <span style="float: right;">1</span>
        </div>
      </div>
      <div>
        <label for="xMin">xMin:</label>
        <input type="number" id="xMin" value="" step="any" style="width: 80px; margin-left: 10px;">
      </div>
      <div>
        <label for="yMin">yMin:</label>
        <input type="number" id="yMin" value="" step="any" style="width: 80px; margin-left: 10px;">
      </div>
    </div>
    <div style="text-align: right;">
      <button id="updateAxes" style="margin-right: 10px;">Update</button>
      <button id="resetAxes">Reset</button>
    </div>
  </div>

</div><!-- End diagram-container -->

<!-- TODO: Remove "random" button -->
<!-- TODO: Make the js code asynchronous, so the page can load quicker (?) -->
<!-- TODO: Implement gridlines -->
<!-- TODO: Set color scheme -->
<!-- TODO: Fix boolean color scheme -->
<!-- TODO:  -->
<!-- TODO:  -->
<!-- TODO:  -->

<script>
  // import {Legend} from "@d3/color-legend"
  // set the dimensions and margins of the graph
  const data = {{ info.get("d3_data") | tojson | safe }};
  console.log(data)
  // Convert string values to numbers to ensure proper numeric comparison
  console.log(data[1].color)
  data.forEach(d => {
      d.x = parseFloat(d.x);
      d.y = parseFloat(d.y);
      const parsedColor = parseFloat(d.color);
      d.color = isNaN(parsedColor) ? (d.color === "true" ? 1 : 0) : parsedColor;
  });

  var margin = {top: 30, right: 30, bottom: 40, left: 100},

      width = 1000 - margin.left - margin.right,
      height = 400 - margin.top - margin.bottom;

  // append the svg object to the body of the page
  var svg = d3.select("#my_dataviz")
      .append("svg")
      .attr("width", width + margin.left + margin.right)
      .attr("height", height + margin.top + margin.bottom);

  // Create main chart group with transform
  var chartGroup = svg.append("g")
      .attr("transform",
            "translate(" + margin.left + "," + margin.top + ")");

  // Add clipPath to prevent points from being drawn outside chart area
  chartGroup.append("defs").append("clipPath")
      .attr("id", "clip")
      .append("rect")
      .attr("width", width)
      .attr("height", height);

  // create a tooltip
  var Tooltip = d3.select("#my_dataviz")
      .append("div")
      .style("opacity", 0)
      .attr("class", "tooltip")
      .style("position", "absolute")
      .style("background-color", "white")
      .style("border", "solid")
      .style("border-width", "2px")
      .style("border-radius", "5px")
      .style("padding", "5px")
      .style("z-index", "1000")
  // Three functions that change the tooltip when user hover / move / leave a cell
  var mouseover = function(d) {
      Tooltip
	  .style("opacity", 1)
      d3.select(this)
	  .style("stroke", "black")
	  .style("opacity", 1)
  }
  var mousemove = function(d) {
      Tooltip
	  .html("Label is " + d.label)
	  .style("left", (d3.mouse(this)[0] + 70) + "px")
	  .style("top", (d3.mouse(this)[1] - 20) + "px")
  }
  var mouseleave = function(d) {
      Tooltip
	  .style("opacity", 0)
      d3.select(this)
	  .style("stroke", "none")
	  .style("opacity", 0.8)
  }
  const baseUrl = window.location.origin;

  // Color scheme definitions
  const colorSchemes = {
      viridis: {
          interpolator: d3.interpolateViridis,
          binary: ['#440154', '#FDE725']
      },
      plasma: {
          interpolator: d3.interpolatePlasma,
          binary: ['#0D0887', '#F0F921']
      },
      inferno: {
          interpolator: d3.interpolateInferno,
          binary: ['#000004', '#FCFFA4']
      },
      cubehelix: {
          interpolator: d3.interpolateCubehelixDefault,
          binary: ['#000000', '#e0ffff']
      },
      warm: {
          interpolator: d3.interpolateWarm,
          binary: ['#6e40aa', '#fbb11b']
      }
  };

  function countUnique(arr) {
      return new Set(arr).size;
  }

  // Check if data is binary (only 2 unique integer values)
  function isBinaryData(data) {
      const uniqueValues = [...new Set(data.map(d => d.color))];
      if (uniqueValues.length !== 2) return false;
      // Check if both are integers
      return uniqueValues.every(v => Number.isInteger(v));
  }

  var numColors = countUnique(data.map(d => d.color));
  var isBinary = isBinaryData(data);
  var currentScheme = 'viridis';

  // Get actual extent of color data for continuous scales
  const colorExtent = d3.extent(data, d => d.color);

  // Create color scale based on data type
  function getColorScale(schemeName) {
      const scheme = colorSchemes[schemeName];
      if (numColors === 1) {
          return d3.scaleOrdinal().range(['black']);
      } else if (isBinary) {
          return d3.scaleOrdinal()
              .domain([0, 1])
              .range(scheme.binary);
      } else {
          return d3.scaleSequential()
              .domain(colorExtent)
              .interpolator(scheme.interpolator);
      }
  }

  var colorScale = getColorScale(currentScheme);

  // Update color preview based on current scheme and data type
  function updateColorPreview() {
      const preview = d3.select("#colorPreview");
      const labels = d3.select("#binaryLabels");
      const scheme = colorSchemes[currentScheme];

      if (numColors === 1) {
          // Single value: black
          preview.style("background", 'black');
          labels.style("display", "none");
      } else if (isBinary) {
          // Binary: show two color swatches side by side
          preview.style("background", `linear-gradient(to right, ${scheme.binary[0]} 50%, ${scheme.binary[1]} 50%)`);
          labels.style("display", "block");
      } else {
          // Continuous: show gradient
          const canvas = document.createElement('canvas');
          canvas.width = 150;
          canvas.height = 20;
          const ctx = canvas.getContext('2d');
          const gradient = ctx.createLinearGradient(0, 0, 150, 0);

          for (let i = 0; i <= 10; i++) {
              const t = i / 10;
              gradient.addColorStop(t, scheme.interpolator(t));
          }

          ctx.fillStyle = gradient;
          ctx.fillRect(0, 0, 150, 20);
          preview.style("background", `url(${canvas.toDataURL()})`);
          preview.style("background-size", "100% 100%");
          labels.style("display", "none");
      }
  }

  // Initialize color preview
  updateColorPreview();

  // Hide color controls if single value
  if (numColors === 1) {
      d3.select("#colorScheme").style("display", "none");
  }

  // Color scheme change handler
  d3.select("#colorScheme").on("change", function() {
      currentScheme = this.value;
      colorScale = getColorScale(currentScheme);
      updateColorPreview();

      // Update all points with new colors
      pointsGroup.selectAll("circle")
          .transition()
          .duration(300)
          .style("fill", d => colorScale(d.color));
  });

  var pointRad = 1.5;

  // Reset slider to default on page load (prevent browser from remembering previous value)
  d3.select("#pointRadius").property("value", 1.5);
  d3.select("#radiusValue").text(1.5);

  // Function to calculate default axis range with 10% leeway on both ends
  // Returns [min, max] where min is 0 if all positive, otherwise min - 10% spread
  // and max is max + 10% spread
  function defaultAxisRange(data, accessor) {
      const values = data.map(accessor);
      const min = d3.min(values);
      const max = d3.max(values);
      const spread = max - min;
      
      // Min: always data min - 10% of spread for proper alignment
      const axisMin = min - (spread / 10);
      // Max: max + 10% of spread
      const axisMax = max + (spread / 10);
      
      return [axisMin, axisMax];
  }
  
  // Calculate default values from data
  const [defaultXMin, defaultXMax] = defaultAxisRange(data, d => d.x)
  const [defaultYMin, defaultYMax] = defaultAxisRange(data, d => d.y)
  
  // Current values (mutable)
  var currentXMin = defaultXMin
  var currentXMax = defaultXMax
  var currentYMin = defaultYMin
  var currentYMax = defaultYMax

  // Axis labels from info
  const xAxisLabel = {{ info.get('x-axis-label') | tojson }}
  const yAxisLabel = {{ info.get('y-axis-label') | tojson }}

  // Initialize input fields with default values
  d3.select("#xMin").property("value", currentXMin)
  d3.select("#xMax").property("value", currentXMax)
  d3.select("#yMin").property("value", currentYMin)
  d3.select("#yMax").property("value", currentYMax)

  // Create axis groups (so they can be cleared and redrawn)
  var xAxisGroup = chartGroup.append("g").attr("class", "x-axis")
  var yAxisGroup = chartGroup.append("g").attr("class", "y-axis")
  var pointsGroup = chartGroup.append("g").attr("class", "points").attr("clip-path", "url(#clip)")

  // Add X axis label
  chartGroup.append("text")
      .attr("x", width / 2)
      .attr("y", height + margin.bottom - 5)
      .style("text-anchor", "middle")
      .style("font-weight", "bold")
      .style("font-family", "sans-serif")
      .text(xAxisLabel)

  // Add Y axis label at top left
  chartGroup.append("text")
      .attr("x", -0)
      .attr("y", -12)
      .style("text-anchor", "middle")
      .style("font-weight", "bold")
      .style("font-family", "sans-serif")
      .text(yAxisLabel)
  
  // Scales (will be updated when axes change)
  var x, y

  // Store initial domain for zoom reset
  const initialXDomain = [currentXMin, currentXMax]
  const initialYDomain = [currentYMin, currentYMax]
  // Legend(d3.scaleSequential([0,100], d3.scaleBlue), {
  //     title: "{{ info.get('color') | tojson }}"
  // })
  // Function to update chart with new axes
  function updateChart() {
      // Update scales
      x = d3.scaleLinear()
          .domain([currentXMin, currentXMax])
          .range([0, width])

      y = d3.scaleLinear()
          .domain([currentYMin, currentYMax])
          .range([height, 0])

      // Update X axis
      xAxisGroup.attr("transform", "translate(0," + height + ")")
          .transition()
          .duration(300)
          .call(d3.axisBottom(x))

      // Update Y axis
      yAxisGroup.transition()
          .duration(300)
          .call(d3.axisLeft(y))

      // Update points with new scales
      var circles = pointsGroup.selectAll("circle")
          .data(data)

      // Update existing points
      circles.transition()
          .duration(300)
          .attr("cx", d => x(d.x))
          .attr("cy", d => y(d.y))

      // Enter new points (if any)
      circles.enter()
          .append("circle")
          .attr("cx", d => x(d.x))
          .attr("cy", d => y(d.y))
          .attr("r", pointRad)
          .style("fill", d => colorScale(d.color))
          .style("opacity", 0.8)
          .on("mouseover", mouseover)
          .on("mousemove", mousemove)
          .on("mouseleave", mouseleave)
          .on("click", (d) => {
              window.location.href = `${baseUrl}/${d.path}`;
          })
  }

  // Create zoom behavior
  var zoom = d3.zoom()
      .scaleExtent([0.5, 50])  // Limit zoom scale
      .extent([[0, 0], [width, height]])
      .on("zoom", zoomed);

  // Apply zoom to the svg
  svg.call(zoom);

  // Zoom event handler
  function zoomed() {
      // Get transformed scales
      var newX = d3.event.transform.rescaleX(x);
      var newY = d3.event.transform.rescaleY(y);

      // Update axes with transformed scales
      xAxisGroup.call(d3.axisBottom(newX));
      yAxisGroup.call(d3.axisLeft(newY));

      // Update points with transformed scales
      pointsGroup.selectAll("circle")
          .attr("cx", d => newX(d.x))
          .attr("cy", d => newY(d.y));

      // Update current domain for input fields
      currentXMin = newX.domain()[0];
      currentXMax = newX.domain()[1];
      currentYMin = newY.domain()[0];
      currentYMax = newY.domain()[1];

      // Update input fields
      d3.select("#xMin").property("value", currentXMin);
      d3.select("#xMax").property("value", currentXMax);
      d3.select("#yMin").property("value", currentYMin);
      d3.select("#yMax").property("value", currentYMax);
  }

  // Initial render
  updateChart()

  // Slider event listener to dynamically update point radius
  d3.select("#pointRadius").on("input", function() {
      const newRadius = +this.value;
      d3.select("#radiusValue").text(newRadius);
      pointRad = newRadius;
      
      d3.selectAll("circle")
          .transition()
          .duration(100)
          .attr("r", newRadius);
  });
  
  // Function to update axes from input fields
  function updateAxesFromInputs() {
      const newXMin = +d3.select("#xMin").property("value")
      const newXMax = +d3.select("#xMax").property("value")
      const newYMin = +d3.select("#yMin").property("value")
      const newYMax = +d3.select("#yMax").property("value")
      
      // Validate inputs
      if (newXMax > newXMin && newYMax > newYMin) {
          currentXMin = newXMin
          currentXMax = newXMax
          currentYMin = newYMin
          currentYMax = newYMax
          updateChart()
      } else {
          alert("xMax must be > xMin and yMax must be > yMin")
      }
  }
  
  // Update button event listener
  d3.select("#updateAxes").on("click", updateAxesFromInputs);
  
  // Enter key event listeners for all axis input fields
  d3.selectAll("#xMin, #xMax, #yMin, #yMax").on("keydown", function() {
      if (d3.event.key === "Enter" || d3.event.keyCode === 13) {
          updateAxesFromInputs();
      }
  });
  
  // Reset button event listener
  d3.select("#resetAxes").on("click", function() {
      currentXMin = defaultXMin
      currentXMax = defaultXMax
      currentYMin = defaultYMin
      currentYMax = defaultYMax
      d3.select("#xMin").property("value", currentXMin)
      d3.select("#xMax").property("value", currentXMax)
      d3.select("#yMin").property("value", currentYMin)
      d3.select("#yMax").property("value", currentYMax)
      d3.select("#pointRadius").property("value", 1.5)
      d3.select("#radiusValue").text(1.5)
      pointRad = 1.5

      // Reset color scheme
      currentScheme = 'viridis'
      d3.select("#colorScheme").property("value", currentScheme)
      colorScale = getColorScale(currentScheme)
      updateColorPreview()

      // Reset zoom transform
      svg.transition()
          .duration(300)
          .call(zoom.transform, d3.zoomIdentity);

      updateChart()

      // Update point radii and colors
      d3.selectAll("circle")
          .transition()
          .duration(100)
          .attr("r", pointRad)
          .style("fill", d => colorScale(d.color));
  });

</script>
{%- endblock content %}
