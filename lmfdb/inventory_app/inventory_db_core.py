import lmfdb_inventory as inv
from lmfdb import db

#Table creation routines -------------------------------------------------------------

def get_db_id(name):
    """ Get database id by name """
    return db.inv_dbs.lucky({'name':name}, '_id')

def get_table_id(name):
    """ Get table id from name """
    return db.inv_tables.lucky({'name':name}, '_id')

def get_db_name(db_id):
    """ Get db name from db id """
    return db.inv_dbs.lucky({'_id':db_id}, 'name')

def get_table_name(table_id):
    """ Get table name from id """
    return db.inv_tables.lucky({'_id':table_id}, 'name')

def get_db(name):
    """ Get database record by name """
    return db.inv_dbs.lucky({'name':name})

def get_table(name):
    """ Get a table record by name """
    return db.inv_tables.lucky({'name':name})

def get_table_by_id(table_id):
    """ Get a table record by id """
    return db.inv_tables.lucky({'_id':table_id})

def get_field(table_id, name, type='auto'):
    """ Return a fields entry

    table_id -- ID of the table that the column belongs to
    name -- The column name
    type -- Specifies human or autogenerated table
    """
    col_db = db.inv_fields_auto if type == 'auto' else db.inv_fields_human
    return col_db.lucky({'table_id':table_id,'name':name})

#End table creation routines -------------------------------------------------------------

#Table sync ------------------------------------------------------------------------------

def trim_human_table(db_id, table_id):
    """Trims elements from the human-readable table which do not match the canonical structure table

    db_id -- id of database to strip
    table_id -- id of table to strip
    """
    invalidated_keys = []
    a_db = db.inv_fields_auto
    h_db = db.inv_fields_human
    #fields_fields = inv.ALL_STRUC.get_fields('human')[inv.STR_CONTENT]
    rec_find = {'table_id':table_id}
    human_cursor = h_db.search(rec_find)
    for record in human_cursor:
        rec_find['name'] = record['name']
        auto_record = a_db.lucky(rec_find)
        if auto_record is None:
            invalidated_keys.append({'name':record['name'], 'data':record['data']})
            h_db.delete(rec_find)
    return invalidated_keys

def complete_human_table(db_id, table_id):
    """Add missing entries into human-readable table. 'Missing' means anything
    present in the auto-generated data but not in the human, AND adds keys present only in the
    human data in also (currently, description)

    db_id -- id of database to strip
    table_id -- id of table to strip
    """
    h_db = db.inv_fields_human
    a_db = db.inv_fields_auto
    #fields_fields = inv.ALL_STRUC.get_fields('human')[inv.STR_CONTENT]
    rec_find = {'table_id':table_id}
    auto_cursor = a_db.find(rec_find)
    for record in auto_cursor:
        rec_find['name'] = record['name']
        human_record = h_db.lucky(rec_find)
        #Should never be two records with same table-id and name
        alter = False
        try:
            rec_set = human_record['data']
        except Exception:
            rec_set = {}
        for field in inv.base_editable_fields:
            try:
                a = human_record['data'][field]
                assert(a or not a) #Use a for Pyflakes, but we don't care what is is
            except Exception:
                rec_set[field] = None
                alter = True
        #Rec_set is now original data plus any missing base_editable_fields
        if alter:
            #Creates if absent, else updates with missing fields
            set_field(table_id, record['name'], rec_set, type='human')

#End table sync --------------------------------------------------------------------------
#Assorted helper access functions --------------------------------------------------------

def count_tables(db_id):
    """ Count tables with given db_id """
    return db.inv_tables.count({'db_id':db_id})

def get_all_tables(db_id):
    """ Fetch all tables with given db_id """
    return list(db.inv_tables.search({'db_id':db_id}))

#End assorted helper access functions ----------------------------------------------------
#Old code from before the switch to postgres ---------------------------------------------

def set_db(name, nice_name):
    raise NotImplementedError
#     """ Insert a new DB with given name and optional nice name (defaults to equal name), or return id if this exists. """
# #TODO make nice_name parameter optional
#     try:
#         table_name = inv.ALL_STRUC.db_ids[inv.STR_NAME]
#         coll = inv_db[table_name]
#     except Exception as e:
#         inv.log_dest.error("Error getting collection "+str(e))
#         return {'err':True, 'id':0, 'exist':False}

#     db_fields = inv.ALL_STRUC.db_ids[inv.STR_CONTENT]
#     record = {db_fields[1]:name}
#     #If record exists, just return its ID
#     exists_at = coll.find_one(record)
#     if exists_at is not None:
#         inv.log_dest.debug("DB exists")
#         _id = exists_at['_id']
#     else:
#         record[db_fields[2]] = nice_name
#         try:
#             _id = coll.insert(record)
#         except Exception as e:
#             inv.log_dest.error("Error inserting new record" +str(e))
#             return {'err':True, 'id':0, 'exist':False}

#     return {'err':False, 'id':_id, 'exist':(exists_at is not None)}

def update_db(db_id, name=None, nice_name=None):
    raise NotImplementedError
#     """"Update DB name or nice_name info by db id"""
#     try:
#         table_name = inv.ALL_STRUC.db_ids[inv.STR_NAME]
#         coll = inv_db[table_name]
#     except Exception as e:
#         inv.log_dest.error("Error getting collection "+str(e))
#         return {'err':True, 'id':0, 'exist':False}

#     db_fields = inv.ALL_STRUC.db_ids[inv.STR_CONTENT]
#     #Look up by Id
#     record = {db_fields[0]:db_id}
#     exists_at = coll.find_one(record)

#     if exists_at is None:
#         inv.log_dest.debug("DB does not exist")
#         return {'err':True, 'id':0, 'exist':False}

#     else:
#         rec_set = {}
#         if name is not None:
#             rec_set[db_fields[1]] = name
#         if nice_name is not None:
#             rec_set[db_fields[2]] = nice_name
#         if rec_set:
#             return update_and_check(inv_db[table_name], record, rec_set)
#         else:
#             return {'err':False, 'id':db_id, 'exist':True}

def set_table(db_id, name, nice_name, notes, info, status):
    raise NotImplementedError
#     """Create or update a collection entry.

#     inv_db -- Connection to LMFDB inventory database
#     db_id -- ID of db this collection is part of
#     name -- Table name to update
#     notes -- The table's notes
#     info -- The table's INFO
#     status -- table's status code
#     """
#     try:
#         table_name = inv.ALL_STRUC.coll_ids[inv.STR_NAME]
#         coll = inv_db[table_name]
#     except Exception as e:
#         inv.log_dest.error("Error getting collection "+str(e))
#         return {'err':True, 'id':0, 'exist':False}

#     coll_fields = inv.ALL_STRUC.coll_ids[inv.STR_CONTENT]
#     rec_find = {coll_fields[1]:db_id, coll_fields[2]:name}
#     rec_set = {}
#     if nice_name is not None:
#         rec_set[coll_fields[3]] = nice_name
#     if notes is not None:
#         rec_set[coll_fields[4]] = notes
#     if info is not None:
#         rec_set[coll_fields[5]] = info
#     if status is not None:
#         rec_set[coll_fields[7]] = status

#     return upsert_and_check(coll, rec_find, rec_set)

def update_table(id, name=None, nice_name=None, status=None):
    raise NotImplementedError
#     """Update a collection entry. Collection must exist.

#     inv_db -- Connection to LMFDB inventory database
#     id -- ID of collection

#     Optional args:
#     name -- new name for collection
#     nice_name -- new nice_name for collection
#     status -- status code
#     """

#     try:
#         table_name = inv.ALL_STRUC.coll_ids[inv.STR_NAME]
#         coll = inv_db[table_name]
#     except Exception as e:
#         inv.log_dest.error("Error getting collection "+str(e))
#         return {'err':True, 'id':0, 'exist':False}
#     coll_fields = inv.ALL_STRUC.coll_ids[inv.STR_CONTENT]
#     rec_find = {coll_fields[0]:id}
#     rec_set = {}
#     if name is not None:
#         rec_set[coll_fields[2]] = name
#     if nice_name is not None:
#         rec_set[coll_fields[3]] = nice_name
#     if status is not None:
#         rec_set[coll_fields[7]] = status
#     if rec_set:
#         return update_and_check(coll, rec_find, rec_set)
#     else:
#         return {'err':False, 'id':id, 'exist':True}

def update_table_data(db_id, name, item, field, content):
    raise NotImplementedError
#     """Update a collection entry. Collection must exist.

#     inv_db -- Connection to LMFDB inventory database
#     db_id -- ID of db this collection is part of
#     item -- The collection info this specifies
#     field -- The piece of information specified (for example, type, description, example)
#     content -- The new value for field
#     """

#     try:
#         table_name = inv.ALL_STRUC.coll_ids[inv.STR_NAME]
#         coll = inv_db[table_name]
#     except Exception as e:
#         inv.log_dest.error("Error getting collection "+str(e))
#         return {'err':True, 'id':0, 'exist':False}
#     coll_fields = inv.ALL_STRUC.coll_ids[inv.STR_CONTENT]
#     rec_find = {coll_fields[1]:db_id, coll_fields[2]:name, item+'.'+field:{"$exists":True}}
#     rec_set = {item+'.'+field:content}

#     return update_and_check(coll, rec_find, rec_set)

def set_table_scrape_date(table_id, scrape_date):
    raise NotImplementedError
#     """Update the last scanned date for given collection"""

#     try:
#         table_name = inv.ALL_STRUC.coll_ids[inv.STR_NAME]
#         coll = inv_db[table_name]
#     except Exception as e:
#         inv.log_dest.error("Error getting collection "+str(e))
#         return {'err':True, 'id':0, 'exist':False}
#     try:
#         assert(isinstance(scrape_date, dt.datetime))
#     except Exception as e:
#         inv.log_dest.error("Invalid scrape_date, expected datetime.datetime "+str(e))
#         return {'err':True, 'id':0, 'exist':False}

#     coll_fields = inv.ALL_STRUC.coll_ids[inv.STR_CONTENT]
#     rec_find = {coll_fields[0]:coll_id}
#     rec_set = {coll_fields[6]:scrape_date}

#     return update_and_check(coll, rec_find, rec_set)

def set_table_status(table_id, status):
    raise NotImplementedError
#     """Update the status code for given collection"""

#     try:
#         table_name = inv.ALL_STRUC.coll_ids[inv.STR_NAME]
#         coll = inv_db[table_name]
#     except Exception as e:
#         inv.log_dest.error("Error getting collection "+str(e))
#         return {'err':True, 'id':0, 'exist':False}

#     coll_fields = inv.ALL_STRUC.coll_ids[inv.STR_CONTENT]
#     rec_find = {coll_fields[0]:coll_id}
#     rec_set = {coll_fields[7]:status}

#     return update_and_check(coll, rec_find, rec_set)

def set_field(table_id, name, data, type='auto'):
    raise NotImplementedError
#     """ Add or update a fields entry.

#     inv_db -- LMFDB connection to inventory db
#     coll_id -- ID of collection field belongs to
#     name -- The lmfdb key this describes
#     data -- Collection data ({field: content, ...} formatted)
#     type -- Specifies human or autogenerated table
#     """
#     #fields_auto = {STR_NAME : 'fields_auto', STR_CONTENT : ['_id', 'coll_id', 'name', 'data']}
#     try:
#         table_name = inv.ALL_STRUC.get_fields(type)[inv.STR_NAME]
#         coll = inv_db[table_name]
#     except Exception as e:
#         inv.log_dest.error("Error getting collection "+ str(e))
#         return {'err':True, 'id':0, 'exist':False}

#     fields_fields = inv.ALL_STRUC.get_fields(type)[inv.STR_CONTENT]
#     rec_find = {fields_fields[1]:coll_id, fields_fields[2]:name}
#     data = ih.null_all_empty_fields(data)
#     rec_set = {fields_fields[3]:data}

#     return upsert_and_check(coll, rec_find, rec_set)

def update_field(table_id, item, field, content, type='auto'):
    raise NotImplementedError
#     """ Update an existing field entry. Item must exist

#     inv_db -- LMFDB connection to inventory db
#     coll_id -- ID of collection field belongs to
#     item -- The lmfdb key this describes
#     field -- The piece of information specified (for example, type, description, example)
#     content -- The new value for field
#     type -- Specifies human or autogenerated table
#     """
#     #fields_auto = {STR_NAME : 'fields_auto', STR_CONTENT : ['_id', 'coll_id', 'name', 'data']}
#     try:
#         table_name = inv.ALL_STRUC.get_fields(type)[inv.STR_NAME]
#         coll = inv_db[table_name]
#     except Exception as e:
#         inv.log_dest.error("Error getting collection " + str(e))
#         return {'err':True, 'id':0, 'exist':False}

#     fields_fields = inv.ALL_STRUC.get_fields(type)[inv.STR_CONTENT]
#     rec_find = {fields_fields[1]:coll_id, fields_fields[2]:item, fields_fields[3]+'.'+field:{"$exists":True}}
#     rec_set = {fields_fields[3]+'.'+field: content}

#     return update_and_check(coll, rec_find, rec_set)

def upsert_and_check(table, rec_find, rec_set):
    raise NotImplementedError
#     """Upsert (insert/update) into given table

#     table -- table to upsert into
#     rec_find -- query to identify possibly existing record
#     rec_set -- new data to set

#     """
#     #Either insert, or update existing and return results
#     try:
#         result = coll.find_and_modify(query=rec_find, update={"$set":rec_set}, upsert=True, full_response=True)
#         if 'upserted' in result['lastErrorObject']:
#             _id = result['lastErrorObject']['upserted']
#         elif 'value' in result:
#             _id = result['value']['_id']
#     except Exception as e:
#         inv.log_dest.error("Error inserting new record "+ str(e))
#         return {'err':True, 'id':0, 'exist':False}
#     return {'err':False, 'id':_id, 'exist':(not 'upserted' in result['lastErrorObject'])}

def update_and_check(table, rec_find, rec_set):
    raise NotImplementedError
#     """Update record in given coll

#     coll -- collection to upsert into
#     rec_find -- query to identify existing record
#     rec_set -- new data to set

#     """

#     try:
#         result = coll.find_and_modify(query=rec_find, update={"$set":rec_set}, upsert=False, full_response=True)
#         _id = result['value']['_id']
#     except Exception as e:
#         #print e
#         inv.log_dest.error("Error updating record "+str(rec_find)+' '+ str(e))
#         return {'err':True, 'id':0, 'exist':False}
#     return {'err':False, 'id':_id, 'exist':True}

#End old code from before the switch to postgres -----------------------------------------
